# Branch Prediction

Module: Computer Systems Organization

---

## 1.6.0 The Microarchitectural Challenge

Branches ( `if`, `for`, `while`, `call`) break the sequential flow of instructions. They introduce a **Control Hazard**.

- **The Problem:** The CPU fetches instructions in Stage 1 (Fetch), but the condition (`if x == 0`) isn't resolved until Stage 10+ (Execute).
    
- **The Dilemma:** What should the CPU fetch during those 10 cycles?
    
    - _Option A (Stall):_ Do nothing. (Result: Massive performance loss).
        
    - _Option B (Speculate):_ Guess the outcome and keep running.
        

### Quantitative Impact

In a deep pipeline (e.g., 20 stages), a stall or a wrong guess costs $\approx 20$ cycles.

If 20% of code is branches (typical in integer workloads):

- **Without Prediction:** $CPI = 1 + (0.20 \times 20) = 5.0$. (The CPU is $5\times$ slower).
    
- **With 95% Accuracy:** $CPI = 1 + (0.20 \times 0.05 \times 20) = 1.2$.
    

> **Conclusion:** High-performance computing is impossible without highly accurate prediction.

---

## 1.6.1 The Mechanics of Prediction

### 1. The Branch Target Buffer (BTB)

The BTB is a specialized cache accessed during the **Fetch Stage**. It answers two questions before the instruction is even decoded:

1. _Is this address a branch?_
    
2. _If yes, where does it jump to?_
    

### 2. Static vs. Dynamic Prediction

- **Static (Compile Time):** Simple rules.
    
    - _Backward Branch:_ Predict **Taken** (Assumes it's a loop).
        
    - _Forward Branch:_ Predict **Not Taken** (Assumes it's an error handling `if`).
        
    - _Accuracy:_ ~60-70%.
        
- **Dynamic (Run Time):** Hardware "learns" from the past behavior of the program.
    
    - _Accuracy:_ >95% (approaching 99% in modern Zen/Core architectures).
        

---

## 1.6.2 Prediction Algorithms

### The 2-Bit Saturating Counter

A state machine that adds "hysteresis" (stability) to predictions. It requires _two_ consecutive mispredictions to change its mind. This is perfect for loops (which loop many times, then exit once).

**States:**

1. **Strongly Taken (11)**
    
2. **Weakly Taken (10)**
    
3. **Weakly Not Taken (01)**
    
4. **Strongly Not Taken (00)**
    

### Global vs. Local History

- **Local History:** "How did _this specific_ branch behave in the past?"
    
    - _Good for:_ Simple loops (`for i=0..100`).
        
- **Global History:** "How did the _last N branches_ in the program behave?"
    
    - _Context:_ If `if(x > 0)` was taken, then `if(x == 5)` is likely taken.
        
    - _Mechanism:_ Uses a **Global History Register (GHR)** to track the path of execution.
        

### State-of-the-Art: TAGE (TAgged GEometric)

Used in Intel Core, AMD Zen, and high-end ARM.

- **Concept:** Uses multiple predictor tables with different history lengths (short history for simple branches, massive history for complex patterns).
    
- **Behavior:** It acts like an ensemble of experts, selecting the predictor with the longest matching history for the current context.
    

---

## 1.6.3 The Cost of Failure: Pipeline Flush

When the predictor guesses wrong (Misprediction):

1. **Squash:** All instructions fetched after the branch (the "Speculative" path) are destroyed.
    
2. **Flush:** The Reorder Buffer (ROB) and Reservation Stations are cleared.
    
3. **Rollback:** The Register Alias Table is reset to the state before the branch.
    
4. **Restart:** The PC is set to the _correct_ path.
    

> Visualizing the Penalty:
> 
> On an Intel Skylake (depth ~14-19), a flush costs ~15-20 cycles.
> 
> On a Pentium 4 (depth ~31), a flush cost ~31 cycles (a major reason for its failure).

---

## 1.6.4 Special Cases

### Loops

Dedicated **Loop Predictors** count iterations.

- _Logic:_ "I have seen this loop run 100 times before. I predict it will run 100 times again."
    
- _Result:_ Perfect prediction on the loop exit (preventing the one misprediction a standard counter would make).
    

### Indirect Branches

Jumps where the target is dynamic (e.g., C++ Virtual Functions, Function Pointers).

- _Mechanism:_ Requires specialized historical tracking of _targets_, not just Taken/Not-Taken status.
    
- _Security Note:_ This is the primary attack surface for **Spectre Variant 2**.
    

---

## 1.6.5 Critical Security Context: Spectre

**Spectre** (2018) fundamentally broke the trust in Branch Prediction.

1. **Poisoning:** An attacker trains the branch predictor to predict "Taken" on a bounds check (e.g., `if (x < array_size)`).
    
2. **Speculation:** The attacker passes a malicious `x` (out of bounds).
    
3. **Execution:** The CPU predicts "Taken" and speculatively reads secret memory (kernel space).
    
4. **Side Channel:** Although the CPU eventually rolls back, the secret data leaves a trace in the **L1 Cache**, which the attacker can measure.
    

---

## üìù Problem Set

### 1. State Machine Logic

Scenario: A 2-bit predictor is in the Weakly Taken (10) state.

Events: The branch is Not Taken.

Question: What is the new state?

Answer: Weakly Not Taken (01). (It moves toward the "Not Taken" side).

### 2. The Loop Problem

**Code:**

C

```
for (int i = 0; i < 5; i++) { ... }
```

Scenario: A 1-bit predictor starts at "Not Taken".

Trace:

1. i=0: Taken (Predict NT -> **Miss**, Flip to T)
    
2. i=1: Taken (Predict T -> **Hit**)
    
3. i=2: Taken (Predict T -> **Hit**)
    
4. i=3: Taken (Predict T -> **Hit**)
    
5. i=4: Not Taken (Exit) (Predict T -> Miss, Flip to NT)
    
    Accuracy: 2 Misses / 5 attempts = 60%.
    
    (Note how a 2-bit predictor or Loop predictor would improve this).
    

### 3. Design Trade-off

Question: Why don't we just make the pipeline shorter (e.g., 3 stages) to reduce the misprediction penalty?

Answer: A short pipeline requires doing more work per stage (Fetch, Decode, and Execute all in one step). This limits the Clock Frequency. Deep pipelines allow GHz-level speeds, but they demand high-accuracy prediction to be viable.

---

## üîó Connection Links

- **‚óÄÔ∏è Previous (1.5):** **Cache Hierarchy**. (Speculative fetching relies on the instruction cache being fast).
    
- **‚ñ∂Ô∏è Next (1.7):** **Microarchitectural Security**. (We will dive deeper into Spectre, Meltdown, and how speculative execution creates vulnerabilities).
    

---

**Would you like to proceed to Section 1.7: Microarchitectural Security?**