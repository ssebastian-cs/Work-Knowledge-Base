# CPU Architecture & Execution

Module: Computer Systems Organization

---
## 1.0 The Central Processing Unit (CPU)

### 1.0.1 Conceptual Overview

The CPU acts as the primary computational engine of the computer, operating on the **Stored Program Concept** (Von Neumann architecture). In this model, instructions and data share the same memory space and are fetched sequentially for execution.

![Image of Von Neumann Architecture diagram showing CPU Memory and I/O](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcRcx1q_kMvNQNJeeY4jh2LFqHnidOCoOfHtDzdOG_rot71DDsD2fsnbVGFXpgne5QitmEcsbJE1LrtyXQQXtUXHzs7RnZnsPBNG19gytL529s9KHw0)

At a functional level, the CPU is a **Finite-State Machine (FSM)** comprised of distinct subsystems interacting to manipulate binary data:

- **Control Unit (CU):** Orchestrates data flow.
    
- **Arithmetic Logic Unit (ALU):** Performs integer math and logic.
    
- **Floating Point Unit (FPU):** Handles fractional/decimal math.
    
- **Registers:** Extremely fast, small on-chip storage.
    
- **Memory Hierarchy:** The pathway for data ingress/egress.
    

### 1.0.2 The Instruction Set Architecture (ISA)

The ISA acts as the contract between the hardware and the software. It defines:

1. **Instruction Repertoire:** Arithmetic, logic, branching, load/store.
    
2. **Register State:** How many registers are available to the programmer.
    
3. **Addressing Modes:** How the CPU calculates memory addresses.
    
4. **Binary Encoding:** The specific bit-patterns for instructions.
    

> **Note on Modern CPUs:** While the ISA defines sequential execution, modern hardware uses **Pipelining**, **Out-of-Order (OoO) execution**, and **Speculative Execution** to optimize throughput while maintaining the _illusion_ of sequential order.

---

## 1.1 The Instruction Cycle (Fetch-Decode-Execute)

### 1.1.1 The Cycle Phases

The "Heartbeat" of the CPU. Every program is a sequence of these cycles.

![Image of CPU Instruction Cycle Fetch Decode Execute diagram](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcTvrkkA7zNPs6BQaf6R8puFpHyi0nKspxP4KkSmGzPhRp4uJZNL24IC52C2M0D1fuwvoWsaNyURCnF6edllmee-eyHJlWNlBK8_ZvcLeu0ZAPDFafM)

| **Phase**         | **Mnemonic** | **Description**                                                                                                                            |
| ----------------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **1. Fetch**      | **IF**       | The CPU uses the **Program Counter (PC)** to retrieve the next instruction from memory and stores it in the **Instruction Register (IR)**. |
| **2. Decode**     | **ID**       | The Control Unit interprets the opcode, identifies source/destination registers, and resolves addressing modes.                            |
| **3. Execute**    | **EX**       | The ALU or FPU performs the actual operation (Math, Logic, or Branch evaluation).                                                          |
| **4. Memory**     | **MEM**      | If required (Load/Store), the CPU accesses the memory subsystem to read or write data.                                                     |
| **5. Write-Back** | **WB**       | Results are committed back to the register file (or memory). The architectural state is updated.                                           |

### 1.1.2 Microarchitectural Implementation

The **Microarchitecture** is the specific hardware implementation of the ISA. It translates the abstract 5-stage cycle into physical reality.

- **Instruction Fetch Unit (IFU):** Uses **Branch Prediction** to guess future control flow and pre-fetch instructions, preventing pipeline starvation.
    
- **Decode Unit:** Translates ISA instructions into internal **Micro-operations (micro-ops)**.
    
    - _RISC (e.g., RISC-V):_ Usually 1:1 mapping (Instruction : Micro-op).
        
    - _CISC (e.g., x86):_ One complex instruction may decode into multiple micro-ops.
        
- **Retirement Unit:** The "Reorder Buffer." It ensures that even if instructions are executed out-of-order for speed, they are retired (completed) in original order to handle exceptions correctly.
    

---

## 1.2 Quantitative Performance

### 1.2.1 The "Iron Law" of Processor Performance

To objectively measure CPU speed, architects use the CPU Performance Equation.

$$\text{CPU Time} = \frac{\text{Instruction Count} \times \text{CPI}}{\text{Clock Frequency}}$$

**Variables:**

- **Instruction Count:** Determined by the compiler and the ISA.
    
- **CPI (Cycles Per Instruction):** The average number of clock cycles needed for one instruction. This is increased by stalls, cache misses, and branch mispredictions.
    
- **Clock Frequency:** The raw speed of the processor (limited by power and physics).
    

> **Optimization Goal:** Modern design aims to **lower the CPI** (via pipelining and OoO execution) and **maximize Frequency**, without exploding power consumption.

---

## 1.3 System Integration & Control

### 1.3.1 The Program Counter (PC) & Flow Control

The PC dictates the sequence of execution.

- **Sequential:** $PC_{next} = PC_{current} + \text{Instruction Length}$
    
- **Branch/Jump:** $PC_{next} = \text{Target Address}$ (Based on conditions like `if x > y`).
    

Critical Component: Branch Prediction Unit (BPU)

The BPU guesses the next PC value to keep the pipeline full.

- _Correct Prediction:_ High performance.
    
- _Misprediction:_ Pipeline flush required (severe performance penalty/high CPI).
    

### 1.3.2 OS-Level Visibility

The Operating System (OS) abstracts the physical CPU into **Logical Processors**. It does not manage the electrical signals but manages the _time_ on the CPU.

**Key OS Responsibilities:**

1. **Context Switching:** Saving the PC and Registers of one thread to load another.
    
2. **Interrupt Handling:** Pausing execution for I/O or timers.
    

Performance Monitoring Tools (e.g., Linux perf):

The OS can query hardware counters to check pipeline health:

- _IPC (Instructions Per Cycle):_ The inverse of CPI.
    
- _Cache Misses:_ Data starvation.
    
- _Branch Mispredictions:_ Wasted work.
    

---

### üìù Review: Self-Assessment

1. **Define:** What is the difference between the ISA and the Microarchitecture?
    
2. **Analyze:** If a CPU has a high clock speed but a high CPI, what bottlenecks might be occurring? (Hint: Memory/Branching).
    
3. **Trace:** Describe the status of the Program Counter during a "Jump" instruction.
    

---